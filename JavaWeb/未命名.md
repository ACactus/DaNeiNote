# SpringMVC 

## 〇、屁话

- 什么是服务器
  * 服务器就是一台高性能的电脑
  * 在这台电脑上安装了提供XXX服务的软件,就称为XXX服务器
  * 举例:
    - 安装了邮件收发服务的软件, 邮件服务器
    - 安装了提供文件上传下载服务的软件, FTP服务器
    - 安装了数据库软件, 就称为数据库服务器
    - 安装了Web服务软件, Web服务器
- Web服务软件做了哪些事儿?
  * Web服务软件不具备任何业务功能, 可以理解为是一个容器, 用来装实现具体业务功能的组件(Servlet是实现具体业务功能的组件, 但是Controller的出现解决了工程Servlet组件太多太杂的问题,可以将多个有相关性的Servlet进行整合)
  * 负责搭建底层的网络连接
  * 负责根据客户端请求的静态资源路径找到对应的静态资源文件,并响应给客户端
  * 负责根据客户端请求的动态资源路径找到对应的Controller并调用里面的方法
- 后端三大框架SSM
  - 后端三大框架的作用是为了提高后端业务功能的开发效率
  - SpringMVC: 从第二阶段开始 到第四阶段
  - Spring: 从第四阶段
  - Mybatis: 从第三阶段开始到第四阶段

## 一、获取请求参数

- 客户端发出请求的几种方式
  1. 在浏览器地址栏中发出请求
  2. 通过超链接发出请求
  3. 通过form表单发出请求
  4. 通过前端框架发出异步请求
- 处理请求时获取参数的几种方式
  1. 通过`HttpServletRequest`对象获取参数, 代码繁琐,而且只能得到字符串类型的参数
  2. 通过参数列表处声明的方式获取, 可以自动进行类型转换
  3. 通过参数列表处声明自定义对象的方式,将接收到的参数直接封装到对象里面,当客户端传递过来的参数大于2个时使用

## 二、常用注解

* `@RequestMapping("/path")`

* `@ResponseBody`

* `@GetMapping("/path")`

* `@PostMapping("/path")`

* `@PathVariable`:

  ```java
  @Controller
  public class DemoController {
  //    @RequestMapping(value = "/c1", method = RequestMethod.GET)
      @GetMapping("/c1/{a}/{b}")
      @ResponseBody
      public String test(@PathVariable("a") Integer a, @PathVariable("b")Integer b){
          return "a=" + a + ",b=" + b;
      }
  }
  ```
  
* `RestController`：

  - 使用次注解 取代`Controller`注解, 相当于在每一个`Controller`中的方法上面都添加了一个`@ResponseBody`注解
  
* `@RequestBody`

  POST方式提交的请求参数获取，需要在变量旁加`@RequestBody`注解

  ```java
  @RestController
  public class AxiosController {
  //    @RequestMapping(path = "/helloPost", method = RequestMethod.POST)
      @PostMapping("/helloPost")
      public String helloAxios(@RequestBody Product product){//使用@RequestBody注解，标明参数来源
          return product.toString();
      }
  }
  
  ```

  


# Mybatis

- Mybatis框架是目前最流行的数据持久层框架, 使用Mybatis框架后, 框架可以帮助我们自动生成JDBC相关代码, 从而提高开发效率, 程序员只需要通过注解或xml配置文件的方式提供好需要执行的SQL语句,框架会自动根据SQL语句以及一些相关指令生成对应的JDBC代码.
- Mybatis框架属于ORM框架, Object Relational Mapping 对象关系映射, 指Java对象和数据库中表的关系, Mybatis框架就是通过两者之间的关系生成的JDBC代码, 使用Mybatis框架需要定义好Mapper映射接口, 在接口中定义两者之间的关系

`@Mapper`注解：置当前接口为 映射接口,映射接口是供Mybatis框架生成JDBC代码的依据,在接口中定义方法和书写SQL语句。

示例：

Poduct实体类如下：

```java
public class Product {
    private Integer id;
    private String title;
    private Integer price;
    private Integer num;

    @Override
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", price=" + price +
                ", num=" + num +
                '}';
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }

    public Integer getNum() {
        return num;
    }

    public void setNum(Integer num) {
        this.num = num;
    }
}
```

Mapper注解使用：

```java
@Mapper
public interface ProductMapper {

    //#{xxx}此指令会从注解下面方法的参数列表中找同名变量,如果找不到
    //则会调用参数列表中变量的同名get方法
    @Insert("insert into product values(null,#{title},#{price},#{num})")
    void insert(Product product);

    //声明返回值类型为List集合 Mybatis框架生成JDBC代码时会自动将查询到的数据
    //封装到Product对象里面, 并且把对象添加到一个list集合中,把集合return出来
    @Select("select id,title,price,num from product")
    List<Product> select();

    //删除注解 定义删除相关的SQL语句
    @Delete("delete from product where id=#{id}")
    void deleteById(int id);
}
```

`@Autowired`注解，Spring提供的注解，Controller类中使用`@Autowired`注解时, Spring框架和Mybatis框架结合根据`Mapper`接口创建出一个实现类,并且实例化了该实现类, 然后mapper则可以直接使用.

```java
@Controller
public class ProductController {
    //Autowired自动装配注解, 此注解是Spring框架中提供的注解
    //此注解添加后是Spring框架和Mybatis框架结合到一起,创建了一个
    //接口的实现类,并且实例化了该实现类 并赋值给了mapper变量
    //实现类中实现了接口里面的抽象方法(insert)
    //(required = false)告诉idea 这个mapper不是必须的
    @Autowired(required = false)
    ProductMapper mapper;
    @RequestMapping("/insert")
    @ResponseBody
    public String insert(Product product){
        System.out.println("product = " + product);
        mapper.insert(product);
        return "添加完成!<a href='/'>返回首页</a>";
    }
}
```

# 前端

### 同步请求和异步请求

- 同步: 指单线程依次做几件事
- 异步: 指多线程同时做几件事
- 同步请求: 指客户端只有一个主线程, 主线程负责页面渲染和监听操作, 如果需要发请求时,主线程会停止渲染页面(清空页面内容) 只负责发请求, 当服务器响应的数据之后,主线程再次恢复渲染工作, 把服务器响应的数据展示到页面中, 只能实现页面的整体改变(整体刷新),无法实现页面的局部改变(局部刷新)
- 异步请求:指主线程只负责渲染页面和监听操作,由子线程负责发请求获取数据,获取到数据后可以将数据展示在原页面的基础之上,这种就称为页面的局部刷新, 只有通过异步请求才能实现页面的局部刷新

### 客户端如何发出异步请求

- 客户端发出请求的方式包括:

  - 浏览器地址栏输入地址 回车后发出请求 同步请求
  - 超链接发出请求 同步请求
  - form表单发出请求 同步请求
  - 通过前端axios框架发出异步请求

- Axios是一个js框架文件, 在html页面中引入此文件即可使用

  https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js

  