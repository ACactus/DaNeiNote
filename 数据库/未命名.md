

## 〇、屁话

数据库管理系统Database management system(简称DBMS)
它们都是独立可运行的软件,我们用java写的程序可以连接这些软件让其负责对数据进行维护
常见的DBMS:

* oracle
* mysql
* DB2
* SQLServer

如何操作DBMS?

* SQL语言:Structured Query Language
* SQL有执行标准:SQL92
* SQL语言是操作DBMS的语言,所有的DBMS都支持标准的SQL语言以及自身提供的可扩展SQL

连接数据库的方式:

1. 命令行(控制台)的客户端
     `show databases`;
2. 图形化界面的客户端
3. IDEA终极版提供了连接数据库的功能
4. 在JAVA中要是用JDBC连接数据库

SQL语句的分类:

* DDL:数据定义语言,用来操作数据库对象(数据库对象:表,索引,序列等都属于数据库对象)
      包含的语法:`CREATE,DROP,ALTER`
* DML:数据操作语言,用来操作表中的数据(包含的操作:对数据的增删改)
      包含的语法:`INSERT,UPDATE,DELETE`
* DQL:数据查询语言,用来查询表中的数据
      包含的语法:`SELECT`
* TCL:事务控制语言
      包含的语法:`COMMIT`,`ROLLBACK`
* DCL:数据控制语言,通常用来让DBA管理数据库使用

## 一、数据库操作

1. 查看DBMS里有多少个数据库
   `SHOW DATABASES`;

2. 新建一个数据库:
   `CREATE DATABASE 数据库名`
   例如:

```sql
CREATE DATABASE mydb;
```

3. 创建一个数据库时可以指定该数据库使用的字符集
   `CREATE DATABASE 数据库名 CHARSET=UTF8/GBK`
   例如:

```sql
CREATE DATABASE mydb2 CHARSET=UTF8
```

4. 查看数据库信息
   `SHOW CREATE DATABASE` 数据库名
   例如:

```sql
SHOW CREATE DATABASE mydb
```

5. 删除数据库
   `DROP DATABASE 数据库名`
   例如:

```sql
DROP DATABASE db1
DROP DATABASE db2
```

6. 使用某个指定的数据库:
   `USE 数据库名`
   例如:
   使用mydb这个数据库:

```sql
USE mydb;
```

## 二、表操作 

1. 创建表

   `CREATE TABLE 表名( 字段名1 数据类型, 字段名2 数据类型, ... ) `

   ```sql
   CREATE TABLE userinfo( id INT, username VARCHAR(30), password VARCHAR(30), nickname VARCHAR(30), age INT );
   ```

2. 查看表的详细信息

   `SHOW CREATE TABLE 表名`

3. 查看表结构

   `DESC 表名`

4. 删除表

   `DROP TABLE 表名`

   ```sql
   DROP TABLE user;
   ```

5. 修改表

   `ALTER TABLE 表名 ...`

   * 修改表名

     `RENAME TABLE 原表名 TO 新表名`

   * 修改表结构

     * 添加列

       `ALTER TABLE 表名 ADD 字段名 字段类型 [FIRST| AFTER 字段名]`

       * 在hero第一列上追加新列

         ```sql
         ALTER TABLE hero ADD id INT FIRST
         ```

       * 向user表中追加性别

         ```sql
         ALTER TABLE user ADD gender VARCHAR(10)
         ```

     * 删除表中字段

       `ALTER TABLE 表明 DROP 字段名`

     * 修改表中字段

       > *注意:可以修改表中字段的类型,长度信息.但是尽量不要在表中包含数据后再进行修改,* *否则可能因为表中现有数据违背该字段修改后的要求导致修改失败.*

       `ALTER TABLE 表名 CHANGE 字段名 新字段名 新字段类型`

       ```sql
       ALTER TABLE hero CHANGE age age VARCHAR(100)
       ```

6. 插入数据

   语法：`INSERT INTO 表名 [(字段1,字段2,...)] VALUES (字段1的值,字段2的值,...)`

   * 在数据库中,字符串是使用单引号的.

   * 在`INSERT`语句中未被指定的列在插入数据时，默认插入`NULL`值。如果未指定的列指定了默认值，则插入指定的默认值
   * 在`INSERT`语句中字段名可以忽略，若忽略则为全列插入，此时`VALUES`后指定的值的顺序，类型，个数必须与表中字段一致

7. 修改表中数据

   语法：`UPDATE 表名 SET 字段名1=字段值1[,字段名2=字段值2,....] [WHERE 过滤条件]`

   ```sql
   将张三的年龄改为22岁:
   UPDATE person
   SET age=22
   WHERE name='张三';    WHERE子句在这里的作用:仅选定表中name字段值为'张三'的记录
   
   将年龄等于15岁的人改为年龄36岁
   UPDATE person
   SET age=36
   WHERE age=15;		  满足WHERE条件的记录都会进行修改
   ```

   `WHERE`子句中常用的条件
   `=`，`<`，`>`，`<=`，`>=`，`<>`(不等于，`!=`不是所有数据库都支持)

   同时修改多个字段

   ```sql
   #将"李四"的名字改为"李老四"并且年龄改为55
   UPDATE person
   SET name='李老四',age=55
   WHERE name='李四'
   ```

   > 字符串的内容是严格区分空格，大小写的。

8. 删除表中数据

   语法：`DELETE [FROM] 表名 [WHERE 过滤条件]`

## 三、数据类型

**不同的数据库管理系统，数据类型不完全一致**

### 1. 数字类型

* 整数类型：`INT(m)`和`BIGINT(m)`

  `m`表示数字的长度（位数）

* 浮点类型：`DOUBLE(m,n)`

  * `m`表示整体数字的位数， `n`表示小数的位数
  * 实际插入数据时如果精度超过了可保存的范围时，会自动进行四舍五入

### 2. 字符类型

* `CHAR(n)`:定长字符串

  * n:长度，单位是**字符**。CHAR(10),该字段可以存放最多10个字符

  * 最大长度:255个字符

  * 表中每条记录该字段在磁盘上占据的空间是固定的，如果实际保存的字符不足指定的长度时，会在后面补充若干个空格来达到长度。

  * **优点:由于长度固定，因此查询速度快**

  * **缺点:磁盘占用存在浪费的情况**

* `VARCHAR(n)`:变长字符串

  * n:长度，单位是**字节**。VARCHAR(10),该字段保存的字符转换的字节最多10个。

  * 最大长度为:65535个字节

  * **优点:实际字段值占用多少字节就在磁盘上开辟多少字节。**

  * **缺点:长度不固定，因此查询性能慢**

* `TEXT(n)`:可变长字符

  n:长度，单位是**字符**。最大值为65535

### 3.日期类型

- `DATE`：可以保存年月日
- `TIME`：保存时分秒
- `DATETIME`：保存年月日时分秒
- `TIMESTAMP`: 时间戳，记录UTC时间。从1970-01-01 00:00:00到其表示的时间之间经过的毫秒

例：

```sql
CREATE TABLE userinfo(
	id INT,
	name VARCHAR(30),
	birth DATETIME,
	salary DOUBLE(7,2)
)
```

插入日期时，可以使用字符串格式，格式应当为:`yyyy-MM-dd hh:mm:ss`

- `MM`表示两个数字的"月"，`mm`表示两位数字的"分"

```sql
INSERT INTO userinfo VALUES(1,'张三','1992-08-02 11:23:56',5000.98)
```

如果日期类型使用的是`DATETIME`，那么在不指定时分秒时，默认为00:00:00

```sql
INSERT INTO userinfo VALUES(2,'李四','1989-06-30',9000)
```

`DATETIME`不能忽略年月日

```sql
INSERT INTO userinfo VALUES(3,'王五','13:25:33',12000)#报错
```

## 四、约束

约束就是为表中某个字段添加一些限制条件，只有符合条件时才可以对表中记录进行操作

**主键约束，外键约束，唯一性约束，非空约束**

### 1. 主键约束

**什么是主键(PRIMARY KEY)**：

* 该字段的值仅表达该表中唯一的一条记录

* 一张表只能有一个字段添加主键约束。该约束要求该字段:**非空且唯一**

### 2.主键约束 (NOT NULL)

添加了非空约束的字段:每条记录该字段的值都不能为NULL

例：

```sql
CREATE TABLE student(
	id INT PRIMARY KEY,
	name VARCHAR(30) NOT NULL,
	age INT(3),
	gender CHAR(1)
) 
```

* 使用`DESC`查看student表结构时可以体现出主键以及非空约束

```sql
DESC student
```

* 不能将`NULL`值插入到主键或者具有非空约束的字段上

```sql
# 当不指定id时，数据库会将NULL默认插入到id字段，这违背主键约束:
INSERT INTO student (name,age,gender) VALUES ('张三',22,'男');

# 不能将NULL值显示的插入到具有非空约束的name字段上:
INSERT INTO student VALUES(1,NULL,22,'男');
```

* 不能将重复的值插入到主键字段中

```sql
INSERT INTO student VALUES(1,'张三',22,'男');

# 不能再将1作为主键的值插入另一条记录。主键字段的值不可重复。
INSERT INTO student VALUES(1,'李四',33,'男');
```

* 主键的值可以由数据库自行维护

```sql
ALTER TABLE student CHANGE id id INT AUTO_INCREMENT;
```

* 当主键字段具有自增效果时，我们可以忽略主键值的插入

```sql
INSERT INTO student (name,age,gender) VALUES('李四',22,'男')
```

* 当主键字段具有自增效果时，我们可以显示的向ID字段插入NULL值.此时主键仍然自增(不推荐操作)

```sql
# 此时并不会将NULL值作为主键字段的值，而是使用自增的主键值。
INSERT INTO student VALUES(NULL,'王五',25,'女')
```

## 五、数据查询语言（DQL)

基本语法：

```sql
SELECT 子句
FROM 子句
JOIN... ON... 子句
WHERE 子句
GROUP BY 子句
HAVING 子句
ORDER BY 子句
```

### 1.SELECT 子句

一条DQL语句必须包含的两个子句分别为:SELECT子句和FROM子句

- SELECT 子句用于选定表中的字段，选定的字段会被包含在查询的结果集中
- FROM 子句用于指定查询的表

查看student表中所有记录，每条记录所有字段都要展示在结果集中。

```sql
SELECT * FROM student
# "*"在SELECT子句中表达的意思时查看表中所有字段。
```

SELECT子句中可以仅指定个别字段进行查询

```sql
# 查看每个学生的名字，年龄，性别
SELECT name,age,gender
FROM student
```

### 2. WHERE子句

**WHERE子句可以添加过滤条件，那么此时仅查询出满足该子句过滤条件的记录**

**比较运算符**:`=,>,>=,<,<=,<>`

例

- 查看所有大队长

  ```sql
  SELECT name,job 
  FROM student
  WHERE job='大队长'
  ```

- 查看除了'刘苍松'以外的其他老师的名字和年龄

  ```sql
  SELECT name,age
  FROM teacher
  WHERE name<>'刘苍松'
  ```

- 查看年龄在30岁以上的老师的名字和年龄(含30岁)

  ```sql
  SELECT name,age
  FROM teacher
  WHERE age>=30
  ```

#### 1) 使用OR,AND来连接多个过滤条件

- `AND`:与。都为真时才为真
- `OR`:或。都为假时才为假

例如

- 查看学生中7岁的大队长都有谁?

  ```sql
  SELECT name,age,job
  FROM student
  WHERE age=7 AND job='大队长'
  ```

- 查看班级号小于6的所有中队长都有谁?(班级号:class_id)

  ```sql
  SELECT name,job,class_id
  FROM student
  WHERE class_id<6 AND job='中队长'
  ```

#### 2) IN /NOT IN

等于列表之一

查看职位是大队长,中队长或小队长的学生?

```sql
SELECT name,job
FROM student
WHERE job='大队长' OR job='中队长' OR job='小队长'
等价
SELECT name,job
FROM student
WHERE job IN('大队长','中队长','小队长')
```

#### 3) BETWEEN...AND...

在两者之间

查看年龄在9到11岁之间的学生都有谁?

```sql
SELECT name,age
FROM student
WHERE age>=9 AND age<=11
等价
SELECT name,age
FROM student
WHERE age BETWEEN 9 AND 11
```

#### 4) DISTINCT 去重

**DISTINCT关键字必须紧跟在SELECT关键字之后**

查看学校的学生有多少种职位?

```sql
SELECT DISTINCT age,job
FROM student
```

#### 5）LIKE 模糊查询

`LIKE`中有两个通配符

- `_ `下划线表示1个字符
- `%` 百分号表示任意个字符(0---多次)

组合示意

- `%X% `字符中含有X的
- `%X` 字符以X结束
- `X%` 字符以X开始
- `_X _ `在三个字符中第二个字符为X
- `%X_` 字符中倒数第二个为X
- `X_Y` 三个字符中第一个为X，第三个为Y
- `X%Y` 字符中第一个是X，最后一个是Y

#### 6)判断NULL值

- `IS NULL` 判断某个字段的值是否为`NULL`
- `IS NOT NULL` 判断某个字段的是不为`NULL`
- **不能直接搭配"="或"<>"来判断NULL值！！！**

查看奖金(comm)为空的老师都有谁?

```sql
SELECT name,salary,comm
FROM teacher
WHERE comm=NULL
上述SQL是查询不到任何数据的!!

正确写法:
SELECT name,salary,comm
FROM teacher
WHERE comm IS NULL
```

#### 7）ORDER BY子句排序

`ORDER BY` 子句只能是DQL中的最后一个子句(原因是该子句是最后执行的子句)。

作用:对结果集按照指定字段值的升序或降序进行排序

排序方式:

- 升序:`ASC` 默认不写就是升序
- 降序:`DESC`

**多字段排序时:会首先按照第一个字段排序，然后当第一个字段值相同的记录中再按照第二个字段排序以此类推**

例:

- 查看老师的工资排名? 按照工资进行降序(从大到小)

  ```sql
  SELECT name,salary,comm
  FROM teacher
  ORDER BY salary DESC
  ```

- 查看老师的奖金?按照升序(从小到大)排序

  ```sql
  SELECT name,salary,comm
  FROM teacher
  ORDER BY comm ASC
  或者
  SELECT name,salary,comm
  FROM teacher
  ORDER BY comm 
  ```

- 按照日期字段排序时，升序为从早到晚

  按照生日从远到近排序学生

  ```sql
  SELECT name,birth
  FROM student
  ORDER BY birth
  ```

- 按照老师的工资降序后再按照奖金的升序排

  ```sql
  SELECT name,salary,comm
  FROM teacher
  ORDER BY salary DESC,comm
  如果第一个字段的值没有重复值，则第二个字段排序无效
  ```

- 按照学生的年龄的升序再按照生日的降序排序

  ```sql
  SELECT name,age,birth
  FROM student
  ORDER BY age,birth
  ```

#### 8) 分页查询

将一个DQL语句执行后的查询结果集分段查询出来。

当一个查询结果记录数非常多时，通常都采取分页查询的方式来分段分批的查询减少不必要的系统开销。

分页查询在SQL92标准中没有定义。意味着不同的数据库有完全不同的分页写法。

**在MySQL中是通过在ORDER BY子句后面追加LIMIT来完成分页的。**

**语法**

 `ORDER BY 字段 LIMIT 跳过的记录数,每页显示的条目数`

 `LIMIT`中两个数字的换算公式:

- `LIMIT (页数-1)*每页显示的条目数 , 每页显示的条目数`

  例如:每页显示5条，显示第三页?

  `LIMIT (3-1)*5,5 `==>` LIMIT 10,5`

  每页显示8条，显示第9页?

  `LIMIT (9-1)*8,8 `==>` LIMIT 64,8`

- 查看老师工资排名的前5名? 分析:按工资降序，分页查询，每页5条，显示第一页

  ```
  SELECT name,salary
  FROM teacher
  ORDER BY salary DESC
  LIMIT 0,5
  ```

- 按照老师奖金的降序排序后，每页显示3条，显示第5页

  ```
  SELECT name,salary,comm
  FROM teacher
  ORDER BY comm DESC
  LIMIT 12,3
  ```

#### 9)DQL中使用表达式或函数的结果查询

1. 在SELECT字句中使用函数或表达式(IFNULL)

   * `IFNULL(arg1,arg2)`:如果arg1不为`NULL`函数直接返回`arg1`,若为`NULL`函数返回`arg2`

   * **任何数字与NULL进行运算结果都是NULL**

   例子：

   - 查看每个老师的年薪是多少? 月薪*12

     ```sql
     SELECT name,salary,salary*12
     FROM teacher
     ```

   - 查看每个老师的工资+奖金的总和是多少? salary+comm

     ```sql
     SELECT name,comm,IFNULL(comm,0)
     FROM teacher
     
     查看老师的工资+奖金
     SELECT name,salary,comm,salary+IFNULL(comm,0)
     FROM teacher
     ```

2. 在WHERE字句中使用函数或表达式作为过滤条件

   **比较运算中也忽略NULL值**

   - 查看年薪小于5万的老师都有谁?

     ```sql
     SELECT name,salary,salary*12
     FROM teacher
     WHERE salary*12<50000
     ```

   - 查看奖金小于3000的老师都有谁?

     ```sql
     SELECT name,salary,comm
     FROM teacher
     WHERE comm<3000
     上述DQL查询的结果集中不含有奖金字段为NULL的记录
     
     SELECT name,salary,comm
     FROM teacher
     WHERE IFNULL(comm,0)<3000
     ```

#### 10)别名

别名在SELECT子句中可以被应用于字段上，函数上或表达式上

别名也可以被应用于其他子句中，比如在FROM子句中为表取别名(后面学习关联查询详细介绍)

1. 字段名 别名

   ```sql
   SELECT name,salary*12 sal FROM teacher
   ```

2. 字段名 AS 别名

   ```sql
   SELECT name,salary*12 AS sal FROM teacher
   ```

3. 字段名 AS '别名' AS可以省略

   ```sql
   SELECT name,salary*12 AS 'sal' FROM teacher
   ```

4. 字段名 AS "别名" AS可以省略

   ```sql
   SELECT name,salary*12 AS "sal" FROM teacher
   ```

#### 11）聚合函数

聚合函数**用来统计**的。可以将一个查询结果集中的多条记录统计为一条。

**聚合函数忽略NULL值，这个在AVG和COUNT中表现最为明显**。

聚合函数:

- `MIN() `求指定字段在结果集中所有记录里的最小值
- `MAX() `求指定字段在结果集中所有记录里的最大值
- `AVG() `求指定字段在结果集中所有记录里的平均值
- `SUM()` 求指定字段在结果集中所有记录里值的总和
- `COUNT()` 不是对字段值的统计，而是对结果集中记录数的统计。统计结果集的记录数

**聚合函数的使用时，首要任务是先将需要统计的所有记录查询出来，之后再加以统计。**

- 查看老师的平均工资是多少?

  1. 先列出所有老师的工资

     ```sql
     SELECT salary FROM teacher
     ```

  2. 对salary加上聚合函数，将结果集中该字段值的所有记录统计平均数

     ```sql
     SELECT AVG(salary) FROM teacher
     ```

- 查看学校老师的最高工资，最低工资，平均工资和工资总和分别是多少?

  ```sql
  SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary)
  FROM teacher
  ```

- 查看负责课程编号1的老师的平均工资是多少?

  1. 查看负责课程编号1的老师的工资?

     ```sql
     SELECT salary FROM teacher WHERE subject_id=1
     ```

  2. 对上述结果集应用聚合函数统计结果

     ```sql
     SELECT AVG(salary) FROM teacher WHERE subject_id=1
     ```

- 查看所有老师的奖金总和和平均奖金是多少?

  ```sql
  SELECT SUM(comm),AVG(comm)
  FROM teacher
  上述DQL查询后实在奖金总和基础上除以15得到的平均值，而非18.因为有3个老师奖金为NULL
  
  可以通过搭配IFNULL来解决:
  SELECT SUM(comm),AVG(IFNULL(comm,0))
  FROM teacher
  ```

- 查看学校一共多少个老师?

  **很多数据库都对COUNT(*)进行过优化，因此统计记录数通常就用它。**

  ```sql
  SELECT COUNT(*) FROM teacher
  ```

- 查看学校年龄最大的大队长生日是哪天?

  寻找student表中所有大队长的生日中距离现在最远的

  ```sql
  SELECT MIN(birth) FROM student WHERE job='大队长'
  ```

#### 12）GROUP BY分组

GROUP BY子句可以将其所在的DQL语句中的查询结果集上按照指定的字段值相同的记录进行分组，搭配聚合函数可以进行组内统计。

**分组是配合统计的，如果SELECT子句中没有聚合函数时，无需使用GROUP BY子句**

例：

1. 查看每个科目的老师的平均工资分别是多少?

   ```sql
   SELECT name,salary,subject_id
   FROM teacher
   ```

   上述SQL会得到结果集

   ![image-20221025190125159](assets/image-20221025190125159.png)

2. 在DQL上添加GROUP BY子句

   ```sql
   SELECT salary,subject_id
   FROM teacher
   GROUP BY subject_id
   
   意思是将:
   SELECT salary,subject_id
   FROM teacher
   查询出的结果集按照subject_id字段值相同的记录分组
   ```

   等同于将结果集分为了五组:

   ![屏幕截图 2022-10-25 190648](assets/屏幕截图 2022-10-25 190648.png)

3. 最终配合聚合函数，可以对结果集中五组数据产生五个统计结果

   ```sql
   SELECT AVG(salary),subject_id
   FROM teacher
   GROUP BY subject_id
   ```

**在SELECT子句中如果包含聚合函数,那么凡是不在聚合函数中的字段都应当出现在GROUP BY子句中**

- 查看学校每种职位的学生各多少人?以及每个职位最大的生日和最小生日?

```sql
SELECT COUNT(*) 总人数,MAX(birth) 最小生日,MIN(birth) 最大生日,job
FROM student
GROUP BY job
```

**GROUP BY可以按照多列分组。结果集中指定的这些列值的组合相同的记录看作一组**

- 查看同班同职位的学生各多少人?

```sql
SELECT COUNT(*)
FROM student
GROUP BY job,class_id
```
